# Contributions
Christopher Dupas (100%) - I worked on everything for this assignment since I'm doing it alone. This includes all of the improvements made to the previous assignment's deliverables, the dirty flag optimization pattern, the observer and state patterns, performance profiling, and the video report.
## Third-party Assets
Breathing sound used for observer pattern found on Freesound (by newlocknew): https://freesound.org/people/newlocknew/sounds/581840/ <br>
Unreal Insights used for performance profiling: https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-insights-in-unreal-engine?application_version=5.3 

# Game Project Description
This scenario has the player exploring a forest where they're collecting resources to bring back to their cabin to protect themselves against monsters when night falls. The player can walk, sprint, jump, crouch, pick up items, and interact with certain objects. They also have a flashlight that they can toggle on and off. They can pick up resources like firewood, planks, and food to use in their cabin. If the player picks up a fruit, they can press the use key to eat it and restore some health. There is no combat, so the player has to either run or hide from the monsters. The player has to go through a single day and survive until morning without getting caught by the monsters. The game can be quit at any time by pressing the escape key.

# Improvements on Previous Deliverables
The first improvement made was to the singleton design pattern and the player's UI. The player's health (HP) and stamina (SP) is now displayed using bars instead of just text. HP uses both text and a bar because the player needs to know precisely how much HP they have at any given time to make proper decisions. SP is just a bar because it gives the player a better look at how much stamina they have left compared to looking at a number rapidly going up or down.<br>
<img width="362" height="131" alt="image" src="https://github.com/user-attachments/assets/1fb50df1-8cdb-46ec-bd7e-394d5cf40d43" />
<br> Another improvement made was to the factory design pattern, where the player can use the "fruit" item. If the player has a fruit in their inventory, and they press the use button, then they will eat the fruit (which removes it from their inventory) and regain some of their health. If there is no fruit in the player's inventory, then nothing will happen. This was done to give the player a reason to pick up one of the items since they can actually do something with the fruit they collect.
<img width="1304" height="291" alt="image" src="https://github.com/user-attachments/assets/f2ddb4ab-b03f-4d17-bc5f-3e4d89859359" />
<br> Another improvement made was to the enemy, which can now move around, either patrolling between a set of waypoints or chasing the player. Using a navigation mesh, the enemy uses "AI MoveTo" to move between different waypoints placed in the level, and if the enemy sees the player, it will start chasing them. This makes the enemy more dynamic by having them move around the environment in a natural way and acting as a threat towards the player.
<img width="1743" height="752" alt="image" src="https://github.com/user-attachments/assets/e8829b9f-9848-4e8a-ae02-69d3708f2c41" />

# Optimization
For my optimization design pattern, I implemented a dirty flag that responds to the player's stamina changing. When the game starts, the flag is marked as "clean", which is done using the function "MarkClean" that sets the "Is Dirty" bool variable to false and also disables the tick event for the player actor. Whenever the player sprints it consumes stamina, which marks the flag as "dirty" using the function "MarkDirty" that sets "Is Dirty" to true and enables the tick event so changes can be updated. This allows the UI to display how much stamina the player has by decreasing it when they're sprinting and increasing it when they're not. Once the player's stamina is full the flag is marked as clean since no more changes need to be made and the tick event won't run unnecessarily. If stamina reaches 0, then the flag is marked as clean because of the observer preventing the player from sprinting for a short time, so no changes will be made to stamina in that time. After this the flag is marked as dirty again when the stamina increases so it can be tracked.
<img width="848" height="1120" alt="image" src="https://github.com/user-attachments/assets/2351f285-2ff5-4a37-93d9-6285b55cafed" />

# Observer
I implemented an observer pattern by having the subject, UIGameInstance, send a notification to all observers when the player runs out of stamina. This is done by getting all actors with the interface BPI_Observer and performing a for loop to call the notify function for each observer. The observer interface, BPI_Observer, creates a notify function that is overwritten for each observer to perform the specific action that it needs to take when something has changed, which is the player's stamina reaching 0. The first observer is the player, which sets the "IsSprinting" bool variable to false and the "IsTired" bool variable to true, forcing the player to stop sprinting and prevents them from sprinting for a few seconds. The other observer is BP_AudioObserver, which simply plays a creepy breathing sound when notified. These observers add to my project since it's a horror game and the player being unable to sprint for a short time after running out of stamina causes them to panic, especially if they're being chased by an enemy. Combining this with the creepy sound effect that is played, it helps add to my project's intended atmosphere by making the player feel uncomfortable and scared.
<img width="737" height="1124" alt="image" src="https://github.com/user-attachments/assets/f6bd8406-ebf4-41ed-bf40-d946454cfcc4" />

# State
I implemented a state pattern for the enemy in my project, BP_NavEnemy, who has 2 states, patrolling and chasing. I used an enumeration and created 2 enumerators for each state of this enemy. The enemy will start off in their patrolling state, where they move between a set of waypoints in the level that are stored in the variable "Waypoints", which is an array of actors. The current waypoint is tracked using the variable "Waypoint Index". When the enemy reaches its current waypoint, it will get the next waypoint and move towards it, and once they reach the last waypoint the index will be set to 0 and they'll move to the first waypoint again. Using the "On See Pawn" event from the pawn sensing component, when the enemy spots the player they will enter the chasing state and follow the player. The enemy will also enter the chasing state if they stop colliding with the player. If the enemy loses sight of the player for too long, they will return to the patrolling state, otherwise they will keep chasing them. This state pattern makes the enemy in my game feel much more alive since they now move around instead of staying still, and switching between patrolling the area and chasing the player makes them dynamic. It also presents a threat to the player since they now have to stay out of the enemy's vision and run away if they get caught.
<img width="750" height="900" alt="image" src="https://github.com/user-attachments/assets/559331f2-55bc-41af-bb05-f3a6aad42efa" />

# Performance Profiling
For each session I tried doing the same things so the comparison would be fair. For the performance without optimization, I disconnected any nodes that marked the flag as dirty or clean and I removed the branch statement in the player event tick that checked if the flag was dirty. This was done so the optimization pattern I implemented wasn't affecting the game's performance. This trace showed the game running at an unsteady framerate for approximately the first half of the session, with several spikes where the frames per second (fps) was really low. The lowest recorded fps was 3.0. For the performance with optimization, I reverted it so the flag would be marked as dirty or clean where it needed to be, ensuring the event tick was only enabled when a change needed to be made to the player's stamina. Compared to the trace without optimization, the game was running at a steadier framerate and there were very few spikes where the fps was lower. The lowest recorded fps was 5.7. <br>
Trace without optimization pattern.
<img width="1917" height="1128" alt="image" src="https://github.com/user-attachments/assets/494831a2-2b3c-4f37-8241-dc52250f1871" />
Trace with optimization pattern (dirty flag).
<img width="1910" height="1131" alt="image" src="https://github.com/user-attachments/assets/32f669f2-a2a2-414c-a3bb-de80e9d4ebad" />
